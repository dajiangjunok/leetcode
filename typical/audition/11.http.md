#### 状态码

- 1xx - 服务器收到请求。【表示目前是协议处理的中间状态，还需要后续操作】
  - 在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码 101。
- 2xx - 请求成功，如 200。【表示成功状态】
  - 200 OK 是见得最多的成功状态码。通常在响应体中放有数据。
  - 204 No Content 含义与 200 相同，但响应头后没有 body 数据
  - 206 Partial Content 顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段 Content-Range。
- 3xx - 重定向，如 302。【重定向状态，资源位置发生变动，需要重新请求】
  - 301 Moved Permanently 即永久重定向，对应着 302 Found，即临时重定向
  - 304 Not Modified: 当协商缓存命中时会返回这个状态码
- 4xx - 客户端错误，如 404。【请求报文有误】
  - 400 Bad Request: 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了
  - 403 Forbidden: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。
  - 404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。
  - 405 Method Not Allowed: 请求方法不被服务器端允许。
  - 406 Not Acceptable: 资源无法满足客户端的条件。
  - 408 Request Timeout: 服务器等待了太长时间。
  - 409 Conflict: 多个请求发生了冲突。
  - 413 Request Entity Too Large: 请求体的数据过大。
  - 414 Request-URI Too Long: 请求行里的 URI 太大。
  - 429 Too Many Request: 客户端发送的请求过多。
  - 431 Request Header Fields Too Large 请求头的字段内容太大。
- 5xx - 服务端错误，如 500。【服务器端发生错误】
  - 500 Internal Server Error: 仅仅告诉你服务器出错了，出了啥错咱也不知道。
  - 501 Not Implemented: 表示客户端请求的功能还不支持。
  - 502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。
  - 503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务。

#### 常见状态码

- 200 - 成功。
- 301 - 永久重定向（配合 location，浏览器自动处理）。
- 302 - 临时重定向（配合 location，浏览器自动处理）。
- 304 - 资源未被修改。
- 403 - 没权限。
- 404 - 资源未找到。
- 500 - 服务器错误。
- 504 - 网关超时。

##### GET 和 POST 有什么区别？

- 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
- 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
- 从幂等性的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)
- 从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

##### 如何理解 URI？

- URI, 全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。【URI 包含 URN 和 URL】

- 协议名【scheme】 主机名和端口【host:port】 请求路径【path】 查询参数【query】 锚点【fragment】
- URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%

##### HTTP 特点

- 特点
  - 灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便
  - 可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了
  - 请求-应答。也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色
  - 无状态。这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。
- 缺点
  - 所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。
  - 在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。
  - 明文传输 即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。 这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。WIFI 陷阱就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。
  - 队头阻塞问题
- https
  - HTTPS 通过 SSL\TLS 进行了加密
  - 是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议

##### 压缩方式

- gzip: 当今最流行的压缩格式
- deflate: 另外一种著名的压缩格式
- br: 一种专门为 HTTP 发明的压缩算法

###### http 协议优点

1.HTTP 使用的是可靠的数据传输协议（底层是 tcp 协议，确保顺序内容的正确性，确保不会丢包），这样可以有效保证用户访问信息的完整性

2.简单快捷：客户向服务器请求服务时，只需传送请求方法和路径，请求方法常用的有 GET,POST,PUT,DELETE 等，

3.灵活：HTTP 允许传输任意类型的数据对象

4.HTTP 协议的无状态性：http 协议自身不对请求和响应之间的通信状态进行保存，对发送过的请求和响应不做持久化处理

##### cookie 和 session 的区别

虽然 cookie 和 session 都可以跟踪客户端的访问记录，但是他们的工作方式显然不同，cookie 通过吧所有要保存的数据通过 http 协议的头部从客户端传递到服务端，又从服务端再传回到客户端，所有的数据都保存在客户端的浏览器里，所以这些 cookie 数据都可以被访问到，不仅仅可以查看访问，通过插件还可以对 cookie 进行增加，修改，因此 cookie 对安全性有一定的缺陷

session 则是将数据保存在服务端，只是通过 cookie 传递一个 sessionID 而已，因此有更高的安全性

1.cookie 存储只能是 ASCII 字符串，session 则可以存储任何数据类型

2.cookie 事明文存储在请求头中，可以被外界访问，甚至修改，删除； session 则是存储在客户端，更加安全

3.有效期不同，cookie 可以设置一个过期时间很长的时间，而 session 则会在关闭阅读器后就会失效

4.服务器压力不同，cookie 存在客户端，对服务器压力小，session 对服务器压力大

5.浏览器支持不同，如果浏览器禁用了 cookie 则会导致会话跟踪失效，session 则不存在类似问题

6.跨域支持不同，cookie 可以通过一下方式实现跨域名访问，将 domain 属性设置为.xxx.com，则 a.xxx.com 和 b.xxx.com 都可以访问，然而 session 仅仅只能所在域名有效

##### 访问一个完整的 http 请求会经历哪些步骤

1.输入 url 后，将 url 交给 dns 域名的解析，根据域名找到对应的 ip 地址和端口号

2.发起 tcp 的 3 次握手

3.建立 TCP 连接后发起 http 请求，发送 header, body 等

4.服务器端响应的 http 请求，将资源封装成响应包返回，关闭连接，浏览器得到 html

5.浏览器解析 html 代码，并请求 html 中的资源，浏览器拿到返回到包做解析，之后再次发送 http 请求拿静态资源

6.浏览器对页面进行渲染呈现给用户

##### TCP/IP 三次握手，四次挥手

1.**第一次握手**：客户端将标志位**SYN 置为 1**，随机产生一个值 seq=J，并将该数据包发送给服务器端，客户端进入 SYN_SENT 状态，等待服务器端确认。

2.**第二次握手**：服务器端收到数据包后由标志位 SYN=1 知道客户端请求建立连接，服务器端将标志位**SYN 和 ACK 都置为 1**，ack=J+1，随机产生一个值 seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入 SYN_RCVD 状态。

3.**第三次握手**：客户端收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位**ACK 置为 1**，ack=K+1，并将该数据包发送给服务器端，服务器端检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手建立连接，随后客户端与服务器端之间可以开始传输数据了。

**为什么 3 次握手**: 前两次的握手很显然是必须的，主要是最后一次，即客户端收到服务端发来的确认后为什么还要想服务端再发送一次确认呢？这主要是**为了防止已失效的请求报文段突然又传送到了服务端而产生连接的误判。**

###### 挥手

1.**第一次挥手**：客户端发送一个**FIN=M**，用来关闭客户端到服务器端的数据传送，客户端进入 FIN_WAIT_1 状态。意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。

2.**第二次挥手**：服务器端收到 FIN 后，先发送**ack=M+1**，告诉客户端，“你的请求我收到了，但是我还没准备好，请继续你等我的消息。”这个时候客户端就进入 FIN_WAIT_2 状态，继续等待服务器端的 FIN 报文。

3.**第三次挥手**：当服务器端确定数据已发送完成，则向客户端发送**FIN=N**报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 LAST_ACK 状态。

4.**第四次挥手**：客户端收到 FIN=N 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送**ACK=1，ack=N+1**后进入 TIME_WAIT 状态，如果服务器端没有收到 ACK 则可以重传。服务器端收到 ACK 后，就知道可以断开连接了（CLOSED 状态）。客户端等待了 2MSL（时间 MSL 叫做最长报文寿命，RFC 建议设为 2 分钟）后依然没有收到回复，则证明服务器端已正常关闭，客户端也可以关闭连接了。最终完成了四次挥手。
